<?php
namespace Entities\Repositories;

use Doctrine\ORM\EntityRepository;
use Entities;

/**
 * EventRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EventRepository extends EntityRepository
{
  /**
   * Returnerer de neste hendelsene basert begrenset opp til $limit
   *
   * @param integer $limit
   * @return \Entities\Event
   */
  public function getNextEvents($limit = 5,$onlyPublic = true,$from = null) {
    //Preload Responsibilities
    //$this->getEntityManager()->getRepository('\Entities\Responsibility')->findAll();
    $q = $this->createQueryBuilder('e')
              ->select('e','s')
              ->leftJoin('e.speaker','s')
            ;
    if($from instanceof \DateTime){
      $q->where('e.end > :from')
        ->setParameter('from', $from, 'datetime');
    }else{
      $q->where('e.end > CURRENT_TIMESTAMP()');
    }
    $q->setMaxResults($limit)
      ->orderBy('e.start', 'ASC');
    if($onlyPublic){
      $q->andWhere('e.isPublic = 1');
    }
    return $q->getQuery()->getResult();
  }
  /**
   *
   * @param User $user
   * @param DateTime $from 
   * @return \Entites\Event
   */
  public function getUserResponsibleEvents( \Entities\User $user, \DateTime $from = null){
    if(is_null($from)){
      $from = new \DateTime();
    }
    // pre fetch all responsibilities from database
    $this->getEntityManager()->getRepository('\Entities\Responsibility')->findAll();
    $q = $this->createQueryBuilder('e')
            ->leftJoin('e.responsibilities', 'r')
            ->where('r.user = :user')
            ->andWhere('e.end > :from')
            ->orderBy('e.start', 'ASC')
            ->setParameter('user', $user)
            ->setParameter('from', $from, 'datetime');
    return $q->getQuery()->execute();
  }
  /**
   * Funksjon som returnerer hendelser som foregår samtidig som andre hendeler
   * Nyttig for å unngå dobbeltbooking ol.
   *
   * @param \Entities\Event $event hendelsn som du vil ha samtidige hendelser til
   * @return \Entities\Event
   */
  public function getConcurrentEvents(\Entities\Event $event){
    $q = $this->getEntityManager()
            ->createQuery('SELECT e FROM Entities\Event e WHERE e.start < :end AND e.end > :start AND e.id != :notId ORDER BY e.start')
            ->setParameter('start',$event->getStart(),'datetime')
            ->setParameter('end',$event->getEnd(),'datetime')
            ->setParameter('notId', $event->getId());
    return $q->getResult();
  }
  public function getEventsBetween(\DateTime $from, \DateTime $to,$onlyPublic = true){
    $days = ($to->getTimestamp() - $from->getTimestamp())/(60*60*24);// difference in days
    if($days > 100 || $days < 0){
      throw new \Exception("Invalid range getEventsBetween(\$from = '$from->format('Y-m-d')', \$to = '$to->format('Y-m-d')')");
    }
    $q = $this->createQueryBuilder('e')
            ->where('e.start < :to')
            ->andWhere('e.end > :from');
    if($onlyPublic){
      $q->andWhere('e.isPublic = :true')
              ->setParameter('true', true,'boolean');
    }
    $q      ->setParameter('to', $to,'datetime')
            ->setParameter('from', $from, 'datetime');
    return $q->getQuery()->getResult();
  }
  /**
   *
   * @param <type> $id
   * @param <type> $onlyPublic
   * @return \Entities\Event
   */
  public function find($id,$onlyPublic){
    $q = $this->createQueryBuilder('e')
            ->where('e.id = :id');
    if($onlyPublic){
      $q->andWhere('e.isPublic = :true')
              ->setParameter('true', true,'boolean');
    }
    $q      ->setParameter('id', (int)$id,'integer');
    try{
      return $q->getQuery()->getSingleResult();
    }catch(\Doctrine\ORM\NoResultException $e){
      return null;
    }
  }
  /**
   *
   * @return \Entites\Event
   */
  public function findAll(){
    return parent::findAll();
  }
}
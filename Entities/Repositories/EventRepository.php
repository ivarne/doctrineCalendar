<?php
namespace Entities\Repositories;

use Doctrine\ORM\EntityRepository;
use Entities;

/**
 * EventRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EventRepository extends EntityRepository
{
  /**
   * Returnerer de neste hendelsene basert begrenset opp til $limit
   *
   * @param integer $limit
   * @return \Entities\Event
   */
  public function getNextEvents($limit = 5,$onlyPublic = true,$from = null) {
    $q = $this->createQueryBuilder('e')
              ->select('e','s')
              ->leftJoin('e.speaker','s')
            ;
    if($from instanceof \DateTime){
      $q->where('e.end > :from')
        ->setParameter('from', $from, 'datetime');
    }else{
      $q->where('e.end > CURRENT_TIMESTAMP()');
    }
    $q->setMaxResults($limit)
      ->orderBy('e.start', 'ASC');
    if($onlyPublic){
      $q->andWhere('e.isPublic = 1');
    }
    return $q->getQuery()->getResult();
  }
  /**
   * Funksjon som returnerer hendelser som foregår samtidig som andre hendeler
   * Nyttig for å unngå dobbeltbooking ol.
   *
   * @param \Entities\Event $event hendelsn som du vil ha samtidige hendelser til
   * @return \Entities\Event
   */
  public function getConcurrentEvents(\Entities\Event $event){
    $q = $this->getEntityManager()
            ->createQuery('SELECT e FROM Entities\Event e WHERE e.start < :end AND e.end > :start AND e.id != :notId ORDER BY e.start')
            ->setParameter('start',$event->getStart(),'datetime')
            ->setParameter('end',$event->getEnd(),'datetime')
            ->setParameter('notId', $event->getId());
    return $q->getResult();
  }
  public function getEventsBetween(\DateTime $from, \DateTime $to,$onlyPublic = true){
    $days = ($to->getTimestamp() - $from->getTimestamp())/(60*60*24);// difference in days
    if($days > 100 || $days < 0){
      throw new \Exception("Invalid range getEventsBetween(\$from = '$from->format('Y-m-d')', \$to = '$to->format('Y-m-d')')");
    }
    $q = $this->createQueryBuilder('e')
            ->where('e.start < :to')
            ->andWhere('e.end > :from');
    if($onlyPublic){
      $q->andWhere('e.isPublic = :true')
              ->setParameter('true', true,'boolean');
    }
    $q      ->setParameter('to', $to,'datetime')
            ->setParameter('from', $from, 'datetime');
    return $q->getQuery()->getResult();
  }
  public function find($id,$onlyPublic){
    $q = $this->createQueryBuilder('e')
            ->where('e.id = :id');
    if($onlyPublic){
      $q->andWhere('e.isPublic = :true')
              ->setParameter('true', true,'boolean');
    }
    $q      ->setParameter('id', (int)$id,'integer');
    return $q->getQuery()->getSingleResult();
  }
}